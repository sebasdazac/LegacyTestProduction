/**
 * Minified by jsDelivr using Terser v5.15.1.
 * Original file: /npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.esm.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
 * chartjs-chart-matrix v2.0.1
 * https://chartjs-chart-matrix.pages.dev/
 * (c) 2023 Jukka Kurkela
 * Released under the MIT license
 */
import{DatasetController,Element}from"chart.js";import{toTRBLCorners,addRoundedRectPath,isObject}from"chart.js/helpers";var version="2.0.1";class MatrixController extends DatasetController{static id="matrix";static version=version;static defaults={dataElementType:"matrix",animations:{numbers:{type:"number",properties:["x","y","width","height"]}}};static overrides={interaction:{mode:"nearest",intersect:!0},scales:{x:{type:"linear",offset:!0},y:{type:"linear",reverse:!0}}};initialize(){this.enableOptionSharing=!0,super.initialize()}update(t){const e=this._cachedMeta;this.updateElements(e.data,0,e.data.length,t)}updateElements(t,e,i,r){const n=this,o="reset"===r,{xScale:a,yScale:s}=n._cachedMeta,l=n.resolveDataElementOptions(e,r),h=n.getSharedOptions(r,t[e],l);for(let l=e;l<e+i;l++){const e=!o&&n.getParsed(l),i=o?a.getBasePixel():a.getPixelForValue(e.x),h=o?s.getBasePixel():s.getPixelForValue(e.y),d=n.resolveDataElementOptions(l,r),{width:c,height:u,anchorX:g,anchorY:p}=d,x={x:resolveX(g,i,c),y:resolveY(p,h,u),width:c,height:u,options:d};n.updateElement(t[l],l,x,r)}n.updateSharedOptions(h,r)}draw(){const t=this,e=t.getMeta().data||[];let i,r;for(i=0,r=e.length;i<r;++i)e[i].draw(t._ctx)}}function resolveX(t,e,i){return"left"===t||"start"===t?e:"right"===t||"end"===t?e-i:e-i/2}function resolveY(t,e,i){return"top"===t||"start"===t?e:"bottom"===t||"end"===t?e-i:e-i/2}function getBounds(t,e){const{x:i,y:r,width:n,height:o}=t.getProps(["x","y","width","height"],e);return{left:i,top:r,right:i+n,bottom:r+o}}function limit(t,e,i){return Math.max(Math.min(t,i),e)}function parseBorderWidth(t,e,i){const r=t.options.borderWidth;let n,o,a,s;return isObject(r)?(n=+r.top||0,o=+r.right||0,a=+r.bottom||0,s=+r.left||0):n=o=a=s=+r||0,{t:limit(n,0,i),r:limit(o,0,e),b:limit(a,0,i),l:limit(s,0,e)}}function boundingRects(t){const e=getBounds(t),i=e.right-e.left,r=e.bottom-e.top,n=parseBorderWidth(t,i/2,r/2);return{outer:{x:e.left,y:e.top,w:i,h:r},inner:{x:e.left+n.l,y:e.top+n.t,w:i-n.l-n.r,h:r-n.t-n.b}}}function inRange(t,e,i,r){const n=null===e,o=null===i,a=!(!t||n&&o)&&getBounds(t,r);return a&&(n||e>=a.left&&e<=a.right)&&(o||i>=a.top&&i<=a.bottom)}class MatrixElement extends Element{static id="matrix";static defaults={backgroundColor:void 0,borderColor:void 0,borderWidth:void 0,borderRadius:0,anchorX:"center",anchorY:"center",width:20,height:20};constructor(t){super(),this.options=void 0,this.width=void 0,this.height=void 0,t&&Object.assign(this,t)}draw(t){const e=this.options,{inner:i,outer:r}=boundingRects(this),n=toTRBLCorners(e.borderRadius);t.save(),r.w!==i.w||r.h!==i.h?(t.beginPath(),addRoundedRectPath(t,{x:r.x,y:r.y,w:r.w,h:r.h,radius:n}),addRoundedRectPath(t,{x:i.x,y:i.y,w:i.w,h:i.h,radius:n}),t.fillStyle=e.backgroundColor,t.fill(),t.fillStyle=e.borderColor,t.fill("evenodd")):(t.beginPath(),addRoundedRectPath(t,{x:i.x,y:i.y,w:i.w,h:i.h,radius:n}),t.fillStyle=e.backgroundColor,t.fill()),t.restore()}inRange(t,e,i){return inRange(this,t,e,i)}inXRange(t,e){return inRange(this,t,null,e)}inYRange(t,e){return inRange(this,null,t,e)}getCenterPoint(t){const{x:e,y:i,width:r,height:n}=this.getProps(["x","y","width","height"],t);return{x:e+r/2,y:i+n/2}}tooltipPosition(){return this.getCenterPoint()}getRange(t){return"x"===t?this.width/2:this.height/2}}export{MatrixController,MatrixElement};
//# sourceMappingURL=/sm/8020f0ec99ba5ab830e095bb68da25c8c1c0264fbe7acb39d91d39efa02e6e25.map