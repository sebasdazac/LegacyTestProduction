/**
 * Minified by jsDelivr using Terser v5.17.1.
 * Original file: /npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.esm.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/*!
* chartjs-plugin-annotation v3.0.1
* https://www.chartjs.org/chartjs-plugin-annotation/index
 * (c) 2023 chartjs-plugin-annotation Contributors
 * Released under the MIT License
 */
import{Element,defaults,Animations,Chart}from"chart.js";import{distanceBetweenPoints,defined,isFunction,callback,isObject,valueOrDefault,toRadians,isArray,toFont,addRoundedRectPath,toTRBLCorners,QUARTER_PI,PI,HALF_PI,TWO_THIRDS_PI,TAU,isNumber,RAD_PER_DEG,toPadding,isFinite,toDegrees,clipArea,unclipArea}from"chart.js/helpers";const interaction={modes:{point:(t,e)=>filterElements(t,e,{intersect:!0}),nearest:(t,e,o)=>getNearestItem(t,e,o),x:(t,e,o)=>filterElements(t,e,{intersect:o.intersect,axis:"x"}),y:(t,e,o)=>filterElements(t,e,{intersect:o.intersect,axis:"y"})}};function getElements(t,e,o){return(interaction.modes[o.mode]||interaction.modes.nearest)(t,e,o)}function inRangeByAxis(t,e,o){return"x"!==o&&"y"!==o?t.inRange(e.x,e.y,"x",!0)||t.inRange(e.x,e.y,"y",!0):t.inRange(e.x,e.y,o,!0)}function getPointByAxis(t,e,o){return"x"===o?{x:t.x,y:e.y}:"y"===o?{x:e.x,y:t.y}:e}function filterElements(t,e,o){return t.visibleElements.filter((t=>o.intersect?t.inRange(e.x,e.y):inRangeByAxis(t,e,o.axis)))}function getNearestItem(t,e,o){let n=Number.POSITIVE_INFINITY;return filterElements(t,e,o).reduce(((t,i)=>{const r=i.getCenterPoint(),a=getPointByAxis(e,r,o.axis),s=distanceBetweenPoints(e,a);return s<n?(t=[i],n=s):s===n&&t.push(i),t}),[]).sort(((t,e)=>t._index-e._index)).slice(0,1)}const isOlderPart=(t,e)=>e>t||t.length>e.length&&t.slice(0,e.length)===e,EPSILON=.001,clamp=(t,e,o)=>Math.min(o,Math.max(e,t));function clampAll(t,e,o){for(const n of Object.keys(t))t[n]=clamp(t[n],e,o);return t}function inPointRange(t,e,o,n){if(!t||!e||o<=0)return!1;const i=n/2;return Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2)<=Math.pow(o+i,2)}function inBoxRange(t,{x:e,y:o,x2:n,y2:i},r,a){const s=a/2,l=t.x>=e-s-EPSILON&&t.x<=n+s+EPSILON,d=t.y>=o-s-EPSILON&&t.y<=i+s+EPSILON;return"x"===r?l:("y"===r||l)&&d}function getElementCenterPoint(t,e){const{centerX:o,centerY:n}=t.getProps(["centerX","centerY"],e);return{x:o,y:n}}function requireVersion(t,e,o,n=!0){const i=o.split(".");let r=0;for(const a of e.split(".")){const s=i[r++];if(parseInt(a,10)<parseInt(s,10))break;if(isOlderPart(s,a)){if(n)throw new Error(`${t} v${o} is not supported. v${e} or newer is required.`);return!1}}return!0}const isPercentString=t=>"string"==typeof t&&t.endsWith("%"),toPercent=t=>parseFloat(t)/100,toPositivePercent=t=>clamp(toPercent(t),0,1),boxAppering=(t,e)=>({x:t,y:e,x2:t,y2:e,width:0,height:0}),defaultInitAnimation={box:t=>boxAppering(t.centerX,t.centerY),ellipse:t=>({centerX:t.centerX,centerY:t.centerX,radius:0,width:0,height:0}),label:t=>boxAppering(t.centerX,t.centerY),line:t=>boxAppering(t.x,t.y),point:t=>({centerX:t.centerX,centerY:t.centerY,radius:0,width:0,height:0}),polygon:t=>boxAppering(t.centerX,t.centerY)};function getRelativePosition(t,e){return"start"===e?0:"end"===e?t:isPercentString(e)?toPositivePercent(e)*t:t/2}function getSize(t,e,o=!0){return"number"==typeof e?e:isPercentString(e)?(o?toPositivePercent(e):toPercent(e))*t:t}function calculateTextAlignment(t,e){const{x:o,width:n}=t,i=e.textAlign;return"center"===i?o+n/2:"end"===i||"right"===i?o+n:o}function toPosition(t,e="center"){return isObject(t)?{x:valueOrDefault(t.x,e),y:valueOrDefault(t.y,e)}:{x:t=valueOrDefault(t,e),y:t}}function isBoundToPoint(t){return t&&(defined(t.xValue)||defined(t.yValue))}function initAnimationProperties(t,e,o){const n=o.init;if(n)return!0===n?applyDefault(e,o):execCallback(t,e,o)}function loadHooks(t,e,o){let n=!1;return e.forEach((e=>{isFunction(t[e])?(n=!0,o[e]=t[e]):defined(o[e])&&delete o[e]})),n}function applyDefault(t,e){const o=e.type||"line";return defaultInitAnimation[o](t)}function execCallback(t,e,o){const n=callback(o.init,[{chart:t,properties:e,options:o}]);return!0===n?applyDefault(e,o):isObject(n)?n:void 0}const widthCache=new Map,notRadius=t=>isNaN(t)||t<=0,fontsKey=t=>t.reduce((function(t,e){return t+=e.string}),"");function isImageOrCanvas(t){if(t&&"object"==typeof t){const e=t.toString();return"[object HTMLImageElement]"===e||"[object HTMLCanvasElement]"===e}}function translate(t,{x:e,y:o},n){n&&(t.translate(e,o),t.rotate(toRadians(n)),t.translate(-e,-o))}function setBorderStyle(t,e){if(e&&e.borderWidth)return t.lineCap=e.borderCapStyle,t.setLineDash(e.borderDash),t.lineDashOffset=e.borderDashOffset,t.lineJoin=e.borderJoinStyle,t.lineWidth=e.borderWidth,t.strokeStyle=e.borderColor,!0}function setShadowStyle(t,e){t.shadowColor=e.backgroundShadowColor,t.shadowBlur=e.shadowBlur,t.shadowOffsetX=e.shadowOffsetX,t.shadowOffsetY=e.shadowOffsetY}function measureLabelSize(t,e){const o=e.content;if(isImageOrCanvas(o))return{width:getSize(o.width,e.width),height:getSize(o.height,e.height)};const n=e.font,i=isArray(n)?n.map((t=>toFont(t))):[toFont(n)],r=e.textStrokeWidth,a=isArray(o)?o:[o],s=a.join()+fontsKey(i)+r+(t._measureText?"-spriting":"");return widthCache.has(s)||widthCache.set(s,calculateLabelSize(t,a,i,r)),widthCache.get(s)}function drawBox(t,e,o){const{x:n,y:i,width:r,height:a}=e;t.save(),setShadowStyle(t,o);const s=setBorderStyle(t,o);t.fillStyle=o.backgroundColor,t.beginPath(),addRoundedRectPath(t,{x:n,y:i,w:r,h:a,radius:clampAll(toTRBLCorners(o.borderRadius),0,Math.min(r,a)/2)}),t.closePath(),t.fill(),s&&(t.shadowColor=o.borderShadowColor,t.stroke()),t.restore()}function drawLabel(t,e,o){const n=o.content;if(isImageOrCanvas(n))return t.save(),t.globalAlpha=getOpacity(o.opacity,n.style.opacity),t.drawImage(n,e.x,e.y,e.width,e.height),void t.restore();const i=isArray(n)?n:[n],r=o.font,a=isArray(r)?r.map((t=>toFont(t))):[toFont(r)],s=o.color,l=isArray(s)?s:[s],d=calculateTextAlignment(e,o),c=e.y+o.textStrokeWidth/2;t.save(),t.textBaseline="middle",t.textAlign=o.textAlign,setTextStrokeStyle(t,o)&&applyLabelDecoration(t,{x:d,y:c},i,a),applyLabelContent(t,{x:d,y:c},i,{fonts:a,colors:l}),t.restore()}function setTextStrokeStyle(t,e){if(e.textStrokeWidth>0)return t.lineJoin="round",t.miterLimit=2,t.lineWidth=e.textStrokeWidth,t.strokeStyle=e.textStrokeColor,!0}function drawPoint(t,e,o,n){const{radius:i,options:r}=e,a=r.pointStyle,s=r.rotation;let l=(s||0)*RAD_PER_DEG;if(isImageOrCanvas(a))return t.save(),t.translate(o,n),t.rotate(l),t.drawImage(a,-a.width/2,-a.height/2,a.width,a.height),void t.restore();notRadius(i)||drawPointStyle(t,{x:o,y:n,radius:i,rotation:s,style:a,rad:l})}function drawPointStyle(t,{x:e,y:o,radius:n,rotation:i,style:r,rad:a}){let s,l,d,c;switch(t.beginPath(),r){default:t.arc(e,o,n,0,TAU),t.closePath();break;case"triangle":t.moveTo(e+Math.sin(a)*n,o-Math.cos(a)*n),a+=TWO_THIRDS_PI,t.lineTo(e+Math.sin(a)*n,o-Math.cos(a)*n),a+=TWO_THIRDS_PI,t.lineTo(e+Math.sin(a)*n,o-Math.cos(a)*n),t.closePath();break;case"rectRounded":c=.516*n,d=n-c,s=Math.cos(a+QUARTER_PI)*d,l=Math.sin(a+QUARTER_PI)*d,t.arc(e-s,o-l,c,a-PI,a-HALF_PI),t.arc(e+l,o-s,c,a-HALF_PI,a),t.arc(e+s,o+l,c,a,a+HALF_PI),t.arc(e-l,o+s,c,a+HALF_PI,a+PI),t.closePath();break;case"rect":if(!i){d=Math.SQRT1_2*n,t.rect(e-d,o-d,2*d,2*d);break}a+=QUARTER_PI;case"rectRot":s=Math.cos(a)*n,l=Math.sin(a)*n,t.moveTo(e-s,o-l),t.lineTo(e+l,o-s),t.lineTo(e+s,o+l),t.lineTo(e-l,o+s),t.closePath();break;case"crossRot":a+=QUARTER_PI;case"cross":s=Math.cos(a)*n,l=Math.sin(a)*n,t.moveTo(e-s,o-l),t.lineTo(e+s,o+l),t.moveTo(e+l,o-s),t.lineTo(e-l,o+s);break;case"star":s=Math.cos(a)*n,l=Math.sin(a)*n,t.moveTo(e-s,o-l),t.lineTo(e+s,o+l),t.moveTo(e+l,o-s),t.lineTo(e-l,o+s),a+=QUARTER_PI,s=Math.cos(a)*n,l=Math.sin(a)*n,t.moveTo(e-s,o-l),t.lineTo(e+s,o+l),t.moveTo(e+l,o-s),t.lineTo(e-l,o+s);break;case"line":s=Math.cos(a)*n,l=Math.sin(a)*n,t.moveTo(e-s,o-l),t.lineTo(e+s,o+l);break;case"dash":t.moveTo(e,o),t.lineTo(e+Math.cos(a)*n,o+Math.sin(a)*n)}t.fill()}function calculateLabelSize(t,e,o,n){t.save();const i=e.length;let r=0,a=n;for(let s=0;s<i;s++){const i=o[Math.min(s,o.length-1)];t.font=i.string;const l=e[s];r=Math.max(r,t.measureText(l).width+n),a+=i.lineHeight}return t.restore(),{width:r,height:a}}function applyLabelDecoration(t,{x:e,y:o},n,i){t.beginPath();let r=0;n.forEach((function(n,a){const s=i[Math.min(a,i.length-1)],l=s.lineHeight;t.font=s.string,t.strokeText(n,e,o+l/2+r),r+=l})),t.stroke()}function applyLabelContent(t,{x:e,y:o},n,{fonts:i,colors:r}){let a=0;n.forEach((function(n,s){const l=r[Math.min(s,r.length-1)],d=i[Math.min(s,i.length-1)],c=d.lineHeight;t.beginPath(),t.font=d.string,t.fillStyle=l,t.fillText(n,e,o+c/2+a),a+=c,t.fill()}))}function getOpacity(t,e){const o=isNumber(t)?t:e;return isNumber(o)?clamp(o,0,1):1}const limitedLineScale={xScaleID:{min:"xMin",max:"xMax",start:"left",end:"right",startProp:"x",endProp:"x2"},yScaleID:{min:"yMin",max:"yMax",start:"bottom",end:"top",startProp:"y",endProp:"y2"}};function scaleValue(t,e,o){return e="number"==typeof e?e:t.parse(e),isFinite(e)?t.getPixelForValue(e):o}function retrieveScaleID(t,e,o){const n=e[o];if(n||"scaleID"===o)return n;const i=o.charAt(0),r=Object.values(t).filter((t=>t.axis&&t.axis===i));return r.length?r[0].id:i}function getDimensionByScale(t,e){if(t){const o=t.options.reverse;return{start:scaleValue(t,e.min,o?e.end:e.start),end:scaleValue(t,e.max,o?e.start:e.end)}}}function getChartPoint(t,e){const{chartArea:o,scales:n}=t,i=n[retrieveScaleID(n,e,"xScaleID")],r=n[retrieveScaleID(n,e,"yScaleID")];let a=o.width/2,s=o.height/2;return i&&(a=scaleValue(i,e.xValue,i.left+i.width/2)),r&&(s=scaleValue(r,e.yValue,r.top+r.height/2)),{x:a,y:s}}function resolveBoxProperties(t,e){const o=t.scales,n=o[retrieveScaleID(o,e,"xScaleID")],i=o[retrieveScaleID(o,e,"yScaleID")];if(!n&&!i)return{};let{left:r,right:a}=n||t.chartArea,{top:s,bottom:l}=i||t.chartArea;const d=getChartDimensionByScale(n,{min:e.xMin,max:e.xMax,start:r,end:a});r=d.start,a=d.end;const c=getChartDimensionByScale(i,{min:e.yMin,max:e.yMax,start:l,end:s});return s=c.start,l=c.end,{x:r,y:s,x2:a,y2:l,width:a-r,height:l-s,centerX:r+(a-r)/2,centerY:s+(l-s)/2}}function resolvePointProperties(t,e){if(!isBoundToPoint(e)){const o=resolveBoxProperties(t,e);let n=e.radius;n&&!isNaN(n)||(n=Math.min(o.width,o.height)/2,e.radius=n);const i=2*n,r=o.centerX+e.xAdjust,a=o.centerY+e.yAdjust;return{x:r-n,y:a-n,x2:r+n,y2:a+n,centerX:r,centerY:a,width:i,height:i,radius:n}}return getChartCircle(t,e)}function resolveLineProperties(t,e){const{scales:o,chartArea:n}=t,i=o[e.scaleID],r={x:n.left,y:n.top,x2:n.right,y2:n.bottom};return i?resolveFullLineProperties(i,r,e):resolveLimitedLineProperties(o,r,e),r}function resolveBoxAndLabelProperties(t,e){const o=resolveBoxProperties(t,e);return o.initProperties=initAnimationProperties(t,o,e),o.elements=[{type:"label",optionScope:"label",properties:resolveLabelElementProperties$1(t,o,e),initProperties:o.initProperties}],o}function getChartCircle(t,e){const o=getChartPoint(t,e),n=2*e.radius;return{x:o.x-e.radius+e.xAdjust,y:o.y-e.radius+e.yAdjust,x2:o.x+e.radius+e.xAdjust,y2:o.y+e.radius+e.yAdjust,centerX:o.x+e.xAdjust,centerY:o.y+e.yAdjust,radius:e.radius,width:n,height:n}}function getChartDimensionByScale(t,e){const o=getDimensionByScale(t,e)||e;return{start:Math.min(o.start,o.end),end:Math.max(o.start,o.end)}}function resolveFullLineProperties(t,e,o){const n=scaleValue(t,o.value,NaN),i=scaleValue(t,o.endValue,n);t.isHorizontal()?(e.x=n,e.x2=i):(e.y=n,e.y2=i)}function resolveLimitedLineProperties(t,e,o){for(const n of Object.keys(limitedLineScale)){const i=t[retrieveScaleID(t,o,n)];if(i){const{min:t,max:r,start:a,end:s,startProp:l,endProp:d}=limitedLineScale[n],c=getDimensionByScale(i,{min:o[t],max:o[r],start:i[a],end:i[s]});e[l]=c.start,e[d]=c.end}}}function calculateX({properties:t,options:e},o,n,i){const{x:r,x2:a,width:s}=t;return calculatePosition$1({start:r,end:a,size:s,borderWidth:e.borderWidth},{position:n.x,padding:{start:i.left,end:i.right},adjust:e.label.xAdjust,size:o.width})}function calculateY({properties:t,options:e},o,n,i){const{y:r,y2:a,height:s}=t;return calculatePosition$1({start:r,end:a,size:s,borderWidth:e.borderWidth},{position:n.y,padding:{start:i.top,end:i.bottom},adjust:e.label.yAdjust,size:o.height})}function calculatePosition$1(t,e){const{start:o,end:n,borderWidth:i}=t,{position:r,padding:{start:a,end:s},adjust:l}=e;return o+i/2+l+getRelativePosition(n-i-o-a-s-e.size,r)}function resolveLabelElementProperties$1(t,e,o){const n=o.label;n.backgroundColor="transparent",n.callout.display=!1;const i=toPosition(n.position),r=toPadding(n.padding),a=measureLabelSize(t.ctx,n),s=calculateX({properties:e,options:o},a,i,r),l=calculateY({properties:e,options:o},a,i,r),d=a.width+r.width,c=a.height+r.height;return{x:s,y:l,x2:s+d,y2:l+c,width:d,height:c,centerX:s+d/2,centerY:l+c/2,rotation:n.rotation}}function rotated(t,e,o){const n=Math.cos(o),i=Math.sin(o),r=e.x,a=e.y;return{x:r+n*(t.x-r)-i*(t.y-a),y:a+i*(t.x-r)+n*(t.y-a)}}const moveHooks=["enter","leave"],eventHooks=moveHooks.concat("click");function updateListeners(t,e,o){e.listened=loadHooks(o,eventHooks,e.listeners),e.moveListened=!1,e._getElements=getElements,moveHooks.forEach((t=>{isFunction(o[t])&&(e.moveListened=!0)})),e.listened&&e.moveListened||e.annotations.forEach((t=>{!e.listened&&isFunction(t.click)&&(e.listened=!0),e.moveListened||moveHooks.forEach((o=>{isFunction(t[o])&&(e.listened=!0,e.moveListened=!0)}))}))}function handleEvent(t,e,o){if(t.listened)switch(e.type){case"mousemove":case"mouseout":return handleMoveEvents(t,e,o);case"click":return handleClickEvents(t,e,o)}}function handleMoveEvents(t,e,o){if(!t.moveListened)return;let n;n="mousemove"===e.type?getElements(t,e,o.interaction):[];const i=t.hovered;t.hovered=n;const r={state:t,event:e};let a=dispatchMoveEvents(r,"leave",i,n);return dispatchMoveEvents(r,"enter",n,i)||a}function dispatchMoveEvents({state:t,event:e},o,n,i){let r;for(const a of n)i.indexOf(a)<0&&(r=dispatchEvent(a.options[o]||t.listeners[o],a,e)||r);return r}function handleClickEvents(t,e,o){const n=t.listeners,i=getElements(t,e,o.interaction);let r;for(const t of i)r=dispatchEvent(t.options.click||n.click,t,e)||r;return r}function dispatchEvent(t,e,o){return!0===callback(t,[e.$context,o])}const elementHooks=["afterDraw","beforeDraw"];function updateHooks(t,e,o){const n=e.visibleElements;e.hooked=loadHooks(o,elementHooks,e.hooks),e.hooked||n.forEach((t=>{e.hooked||elementHooks.forEach((o=>{isFunction(t.options[o])&&(e.hooked=!0)}))}))}function invokeHook(t,e,o){if(t.hooked){const n=e.options[o]||t.hooks[o];return callback(n,[e.$context])}}function adjustScaleRange(t,e,o){const n=getScaleLimits(t.scales,e,o);let i=changeScaleLimit(e,n,"min","suggestedMin");i=changeScaleLimit(e,n,"max","suggestedMax")||i,i&&isFunction(e.handleTickRangeOptions)&&e.handleTickRangeOptions()}function verifyScaleOptions(t,e){for(const o of t)verifyScaleIDs(o,e)}function changeScaleLimit(t,e,o,n){if(isFinite(e[o])&&!scaleLimitDefined(t.options,o,n)){const n=t[o]!==e[o];return t[o]=e[o],n}}function scaleLimitDefined(t,e,o){return defined(t[e])||defined(t[o])}function verifyScaleIDs(t,e){for(const o of["scaleID","xScaleID","yScaleID"]){const n=retrieveScaleID(e,t,o);n&&!e[n]&&verifyProperties(t,o)&&console.warn(`No scale found with id '${n}' for annotation '${t.id}'`)}}function verifyProperties(t,e){if("scaleID"===e)return!0;const o=e.charAt(0);for(const e of["Min","Max","Value"])if(defined(t[o+e]))return!0;return!1}function getScaleLimits(t,e,o){const n=e.axis,i=e.id,r=n+"ScaleID",a={min:valueOrDefault(e.min,Number.NEGATIVE_INFINITY),max:valueOrDefault(e.max,Number.POSITIVE_INFINITY)};for(const s of o)s.scaleID===i?updateLimits(s,e,["value","endValue"],a):retrieveScaleID(t,s,r)===i&&updateLimits(s,e,[n+"Min",n+"Max",n+"Value"],a);return a}function updateLimits(t,e,o,n){for(const i of o){const o=t[i];if(defined(o)){const t=e.parse(o);n.min=Math.min(n.min,t),n.max=Math.max(n.max,t)}}}class BoxAnnotation extends Element{inRange(t,e,o,n){const{x:i,y:r}=rotated({x:t,y:e},this.getCenterPoint(n),toRadians(-this.options.rotation));return inBoxRange({x:i,y:r},this.getProps(["x","y","x2","y2"],n),o,this.options.borderWidth)}getCenterPoint(t){return getElementCenterPoint(this,t)}draw(t){t.save(),translate(t,this.getCenterPoint(),this.options.rotation),drawBox(t,this,this.options),t.restore()}get label(){return this.elements&&this.elements[0]}resolveElementProperties(t,e){return resolveBoxAndLabelProperties(t,e)}}BoxAnnotation.id="boxAnnotation",BoxAnnotation.defaults={adjustScaleRange:!0,backgroundShadowColor:"transparent",borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderRadius:0,borderShadowColor:"transparent",borderWidth:1,display:!0,init:void 0,label:{backgroundColor:"transparent",borderWidth:0,callout:{display:!1},color:"black",content:null,display:!1,drawTime:void 0,font:{family:void 0,lineHeight:void 0,size:void 0,style:void 0,weight:"bold"},height:void 0,opacity:void 0,padding:6,position:"center",rotation:void 0,textAlign:"start",textStrokeColor:void 0,textStrokeWidth:0,width:void 0,xAdjust:0,yAdjust:0,z:void 0},rotation:0,shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,xMax:void 0,xMin:void 0,xScaleID:void 0,yMax:void 0,yMin:void 0,yScaleID:void 0,z:0},BoxAnnotation.defaultRoutes={borderColor:"color",backgroundColor:"color"},BoxAnnotation.descriptors={label:{_fallback:!0}};const positions=["left","bottom","top","right"];class LabelAnnotation extends Element{inRange(t,e,o,n){const{x:i,y:r}=rotated({x:t,y:e},this.getCenterPoint(n),toRadians(-this.rotation));return inBoxRange({x:i,y:r},this.getProps(["x","y","x2","y2"],n),o,this.options.borderWidth)}getCenterPoint(t){return getElementCenterPoint(this,t)}draw(t){const e=this.options,o=!defined(this._visible)||this._visible;e.display&&e.content&&o&&(t.save(),translate(t,this.getCenterPoint(),this.rotation),drawCallout(t,this),drawBox(t,this,e),drawLabel(t,getLabelSize(this),e),t.restore())}resolveElementProperties(t,e){let o;if(isBoundToPoint(e))o=getChartPoint(t,e);else{const{centerX:n,centerY:i}=resolveBoxProperties(t,e);o={x:n,y:i}}const n=toPadding(e.padding),i=measureRect(o,measureLabelSize(t.ctx,e),e,n);return{initProperties:initAnimationProperties(t,i,e),pointX:o.x,pointY:o.y,...i,rotation:e.rotation}}}function measureRect(t,e,o,n){const i=e.width+n.width+o.borderWidth,r=e.height+n.height+o.borderWidth,a=toPosition(o.position,"center"),s=calculatePosition(t.x,i,o.xAdjust,a.x),l=calculatePosition(t.y,r,o.yAdjust,a.y);return{x:s,y:l,x2:s+i,y2:l+r,width:i,height:r,centerX:s+i/2,centerY:l+r/2}}function calculatePosition(t,e,o=0,n){return t-getRelativePosition(e,n)+o}function drawCallout(t,e){const{pointX:o,pointY:n,options:i}=e,r=i.callout,a=r&&r.display&&resolveCalloutPosition(e,r);if(!a||isPointInRange(e,r,a))return;t.save(),t.beginPath();if(!setBorderStyle(t,r))return t.restore();const{separatorStart:s,separatorEnd:l}=getCalloutSeparatorCoord(e,a),{sideStart:d,sideEnd:c}=getCalloutSideCoord(e,a,s);(r.margin>0||0===i.borderWidth)&&(t.moveTo(s.x,s.y),t.lineTo(l.x,l.y)),t.moveTo(d.x,d.y),t.lineTo(c.x,c.y);const u=rotated({x:o,y:n},e.getCenterPoint(),toRadians(-e.rotation));t.lineTo(u.x,u.y),t.stroke(),t.restore()}function getCalloutSeparatorCoord(t,e){const{x:o,y:n,x2:i,y2:r}=t,a=getCalloutSeparatorAdjust(t,e);let s,l;return"left"===e||"right"===e?(s={x:o+a,y:n},l={x:s.x,y:r}):(s={x:o,y:n+a},l={x:i,y:s.y}),{separatorStart:s,separatorEnd:l}}function getCalloutSeparatorAdjust(t,e){const{width:o,height:n,options:i}=t,r=i.callout.margin+i.borderWidth/2;return"right"===e?o+r:"bottom"===e?n+r:-r}function getCalloutSideCoord(t,e,o){const{y:n,width:i,height:r,options:a}=t,s=a.callout.start,l=getCalloutSideAdjust(e,a.callout);let d,c;return"left"===e||"right"===e?(d={x:o.x,y:n+getSize(r,s)},c={x:d.x+l,y:d.y}):(d={x:o.x+getSize(i,s),y:o.y},c={x:d.x,y:d.y+l}),{sideStart:d,sideEnd:c}}function getCalloutSideAdjust(t,e){const o=e.side;return"left"===t||"top"===t?-o:o}function resolveCalloutPosition(t,e){const o=e.position;return positions.includes(o)?o:resolveCalloutAutoPosition(t,e)}function resolveCalloutAutoPosition(t,e){const{x:o,y:n,x2:i,y2:r,width:a,height:s,pointX:l,pointY:d,centerX:c,centerY:u,rotation:h}=t,p={x:c,y:u},y=e.start,f=getSize(a,y),x=[o,o+f,o+f,i],g=[n+getSize(s,y),r,n,r],b=[];for(let t=0;t<4;t++){const e=rotated({x:x[t],y:g[t]},p,toRadians(h));b.push({position:positions[t],distance:distanceBetweenPoints(e,{x:l,y:d})})}return b.sort(((t,e)=>t.distance-e.distance))[0].position}function getLabelSize({x:t,y:e,width:o,height:n,options:i}){const r=i.borderWidth/2,a=toPadding(i.padding);return{x:t+a.left+r,y:e+a.top+r,width:o-a.left-a.right-i.borderWidth,height:n-a.top-a.bottom-i.borderWidth}}function isPointInRange(t,e,o){const{pointX:n,pointY:i}=t,r=e.margin;let a=n,s=i;return"left"===o?a+=r:"right"===o?a-=r:"top"===o?s+=r:"bottom"===o&&(s-=r),t.inRange(a,s)}LabelAnnotation.id="labelAnnotation",LabelAnnotation.defaults={adjustScaleRange:!0,backgroundColor:"transparent",backgroundShadowColor:"transparent",borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderRadius:0,borderShadowColor:"transparent",borderWidth:0,callout:{borderCapStyle:"butt",borderColor:void 0,borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:1,display:!1,margin:5,position:"auto",side:5,start:"50%"},color:"black",content:null,display:!0,font:{family:void 0,lineHeight:void 0,size:void 0,style:void 0,weight:void 0},height:void 0,init:void 0,opacity:void 0,padding:6,position:"center",rotation:0,shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,textAlign:"center",textStrokeColor:void 0,textStrokeWidth:0,width:void 0,xAdjust:0,xMax:void 0,xMin:void 0,xScaleID:void 0,xValue:void 0,yAdjust:0,yMax:void 0,yMin:void 0,yScaleID:void 0,yValue:void 0,z:0},LabelAnnotation.defaultRoutes={borderColor:"color"};const pointInLine=(t,e,o)=>({x:t.x+o*(e.x-t.x),y:t.y+o*(e.y-t.y)}),interpolateX=(t,e,o)=>pointInLine(e,o,Math.abs((t-e.y)/(o.y-e.y))).x,interpolateY=(t,e,o)=>pointInLine(e,o,Math.abs((t-e.x)/(o.x-e.x))).y,sqr=t=>t*t,rangeLimit=(t,e,{x:o,y:n,x2:i,y2:r},a)=>"y"===a?{start:Math.min(n,r),end:Math.max(n,r),value:e}:{start:Math.min(o,i),end:Math.max(o,i),value:t},coordInCurve=(t,e,o,n)=>(1-n)*(1-n)*t+2*(1-n)*n*e+n*n*o,pointInCurve=(t,e,o,n)=>({x:coordInCurve(t.x,e.x,o.x,n),y:coordInCurve(t.y,e.y,o.y,n)}),coordAngleInCurve=(t,e,o,n)=>2*(1-n)*(e-t)+2*n*(o-e),angleInCurve=(t,e,o,n)=>-Math.atan2(coordAngleInCurve(t.x,e.x,o.x,n),coordAngleInCurve(t.y,e.y,o.y,n))+.5*PI;class LineAnnotation extends Element{inRange(t,e,o,n){const i=this.options.borderWidth/2;if("x"!==o&&"y"!==o){const o={mouseX:t,mouseY:e},{path:r,ctx:a}=this;if(r){setBorderStyle(a,this.options);const{chart:i}=this.$context,s=t*i.currentDevicePixelRatio,l=e*i.currentDevicePixelRatio,d=a.isPointInStroke(r,s,l)||isOnLabel(this,o,n);return a.restore(),d}return intersects(this,o,sqr(i),n)||isOnLabel(this,o,n)}return inAxisRange(this,{mouseX:t,mouseY:e},o,{hBorderWidth:i,useFinalPosition:n})}getCenterPoint(t){return getElementCenterPoint(this,t)}draw(t){const{x:e,y:o,x2:n,y2:i,cp:r,options:a}=this;if(t.save(),!setBorderStyle(t,a))return t.restore();setShadowStyle(t,a);const s=Math.sqrt(Math.pow(n-e,2)+Math.pow(i-o,2));if(a.curve&&r)return drawCurve(t,this,r,s),t.restore();const{startOpts:l,endOpts:d,startAdjust:c,endAdjust:u}=getArrowHeads(this),h=Math.atan2(i-o,n-e);t.translate(e,o),t.rotate(h),t.beginPath(),t.moveTo(0+c,0),t.lineTo(s-u,0),t.shadowColor=a.borderShadowColor,t.stroke(),drawArrowHead(t,0,c,l),drawArrowHead(t,s,-u,d),t.restore()}get label(){return this.elements&&this.elements[0]}resolveElementProperties(t,e){const o=resolveLineProperties(t,e),{x:n,y:i,x2:r,y2:a}=o,s=isLineInArea(o,t.chartArea),l=s?limitLineToArea({x:n,y:i},{x:r,y:a},t.chartArea):{x:n,y:i,x2:r,y2:a,width:Math.abs(r-n),height:Math.abs(a-i)};if(l.centerX=(r+n)/2,l.centerY=(a+i)/2,l.initProperties=initAnimationProperties(t,l,e),e.curve){const t={x:l.x,y:l.y},o={x:l.x2,y:l.y2};l.cp=getControlPoint(l,e,distanceBetweenPoints(t,o))}const d=resolveLabelElementProperties(t,l,e.label);return d._visible=s,l.elements=[{type:"label",optionScope:"label",properties:d,initProperties:l.initProperties}],l}}LineAnnotation.id="lineAnnotation";const arrowHeadsDefaults={backgroundColor:void 0,backgroundShadowColor:void 0,borderColor:void 0,borderDash:void 0,borderDashOffset:void 0,borderShadowColor:void 0,borderWidth:void 0,display:void 0,fill:void 0,length:void 0,shadowBlur:void 0,shadowOffsetX:void 0,shadowOffsetY:void 0,width:void 0};function inAxisRange(t,{mouseX:e,mouseY:o},n,{hBorderWidth:i,useFinalPosition:r}){const a=rangeLimit(e,o,t.getProps(["x","y","x2","y2"],r),n);return a.value>=a.start-i&&a.value<=a.end+i||isOnLabel(t,{mouseX:e,mouseY:o},r,n)}function isLineInArea({x:t,y:e,x2:o,y2:n},{top:i,right:r,bottom:a,left:s}){return!(t<s&&o<s||t>r&&o>r||e<i&&n<i||e>a&&n>a)}function limitPointToArea({x:t,y:e},o,{top:n,right:i,bottom:r,left:a}){return t<a&&(e=interpolateY(a,{x:t,y:e},o),t=a),t>i&&(e=interpolateY(i,{x:t,y:e},o),t=i),e<n&&(t=interpolateX(n,{x:t,y:e},o),e=n),e>r&&(t=interpolateX(r,{x:t,y:e},o),e=r),{x:t,y:e}}function limitLineToArea(t,e,o){const{x:n,y:i}=limitPointToArea(t,e,o),{x:r,y:a}=limitPointToArea(e,t,o);return{x:n,y:i,x2:r,y2:a,width:Math.abs(r-n),height:Math.abs(a-i)}}function intersects(t,{mouseX:e,mouseY:o},n=EPSILON,i){const{x:r,y:a,x2:s,y2:l}=t.getProps(["x","y","x2","y2"],i),d=s-r,c=l-a,u=sqr(d)+sqr(c),h=0===u?-1:((e-r)*d+(o-a)*c)/u;let p,y;return h<0?(p=r,y=a):h>1?(p=s,y=l):(p=r+h*d,y=a+h*c),sqr(e-p)+sqr(o-y)<=n}function isOnLabel(t,{mouseX:e,mouseY:o},n,i){const r=t.label;return r.options.display&&r.inRange(e,o,i,n)}function resolveLabelElementProperties(t,e,o){const n=o.borderWidth,i=toPadding(o.padding),r=measureLabelSize(t.ctx,o);return calculateLabelPosition(e,o,{width:r.width+i.width+n,height:r.height+i.height+n,padding:i},t.chartArea)}function calculateAutoRotation(t){const{x:e,y:o,x2:n,y2:i}=t,r=Math.atan2(i-o,n-e);return r>PI/2?r-PI:r<PI/-2?r+PI:r}function calculateLabelPosition(t,e,o,n){const{width:i,height:r,padding:a}=o,{xAdjust:s,yAdjust:l}=e,d={x:t.x,y:t.y},c={x:t.x2,y:t.y2},u="auto"===e.rotation?calculateAutoRotation(t):toRadians(e.rotation),h=rotatedSize(i,r,u),p=calculateT(t,e,{labelSize:h,padding:a},n),y=t.cp?pointInCurve(d,t.cp,c,p):pointInLine(d,c,p),f={size:h.w,min:n.left,max:n.right,padding:a.left},x={size:h.h,min:n.top,max:n.bottom,padding:a.top},g=adjustLabelCoordinate(y.x,f)+s,b=adjustLabelCoordinate(y.y,x)+l;return{x:g-i/2,y:b-r/2,x2:g+i/2,y2:b+r/2,centerX:g,centerY:b,pointX:y.x,pointY:y.y,width:i,height:r,rotation:toDegrees(u)}}function rotatedSize(t,e,o){const n=Math.cos(o),i=Math.sin(o);return{w:Math.abs(t*n)+Math.abs(e*i),h:Math.abs(t*i)+Math.abs(e*n)}}function calculateT(t,e,o,n){let i;const r=spaceAround(t,n);return i="start"===e.position?calculateTAdjust({w:t.x2-t.x,h:t.y2-t.y},o,e,r):"end"===e.position?1-calculateTAdjust({w:t.x-t.x2,h:t.y-t.y2},o,e,r):getRelativePosition(1,e.position),i}function calculateTAdjust(t,e,o,n){const{labelSize:i,padding:r}=e,a=t.w*n.dx,s=t.h*n.dy,l=a>0&&(i.w/2+r.left-n.x)/a,d=s>0&&(i.h/2+r.top-n.y)/s;return clamp(Math.max(l,d),0,.25)}function spaceAround(t,e){const{x:o,x2:n,y:i,y2:r}=t,a=Math.min(i,r)-e.top,s=Math.min(o,n)-e.left,l=e.bottom-Math.max(i,r),d=e.right-Math.max(o,n);return{x:Math.min(s,d),y:Math.min(a,l),dx:s<=d?1:-1,dy:a<=l?1:-1}}function adjustLabelCoordinate(t,e){const{size:o,min:n,max:i,padding:r}=e,a=o/2;return o>i-n?(i+n)/2:(n>=t-r-a&&(t=n+r+a),i<=t+r+a&&(t=i-r-a),t)}function getArrowHeads(t){const e=t.options,o=e.arrowHeads&&e.arrowHeads.start,n=e.arrowHeads&&e.arrowHeads.end;return{startOpts:o,endOpts:n,startAdjust:getLineAdjust(t,o),endAdjust:getLineAdjust(t,n)}}function getLineAdjust(t,e){if(!e||!e.display)return 0;const{length:o,width:n}=e,i=t.options.borderWidth/2,r={x:o,y:n+i},a={x:0,y:i};return Math.abs(interpolateX(0,r,a))}function drawArrowHead(t,e,o,n){if(!n||!n.display)return;const{length:i,width:r,fill:a,backgroundColor:s,borderColor:l}=n,d=Math.abs(e-i)+o;t.beginPath(),setShadowStyle(t,n),setBorderStyle(t,n),t.moveTo(d,-r),t.lineTo(e+o,0),t.lineTo(d,r),!0===a?(t.fillStyle=s||l,t.closePath(),t.fill(),t.shadowColor="transparent"):t.shadowColor=n.borderShadowColor,t.stroke()}function getControlPoint(t,e,o){const{x:n,y:i,x2:r,y2:a,centerX:s,centerY:l}=t,d=Math.atan2(a-i,r-n),c=toPosition(e.controlPoint,0);return rotated({x:s+getSize(o,c.x,!1),y:l+getSize(o,c.y,!1)},{x:s,y:l},d)}function drawArrowHeadOnCurve(t,{x:e,y:o},{angle:n,adjust:i},r){r&&r.display&&(t.save(),t.translate(e,o),t.rotate(n),drawArrowHead(t,0,-i,r),t.restore())}function drawCurve(t,e,o,n){const{x:i,y:r,x2:a,y2:s,options:l}=e,{startOpts:d,endOpts:c,startAdjust:u,endAdjust:h}=getArrowHeads(e),p={x:i,y:r},y={x:a,y:s},f=angleInCurve(p,o,y,0),x=angleInCurve(p,o,y,1)-PI,g=pointInCurve(p,o,y,u/n),b=pointInCurve(p,o,y,1-h/n),m=new Path2D;t.beginPath(),m.moveTo(g.x,g.y),m.quadraticCurveTo(o.x,o.y,b.x,b.y),t.shadowColor=l.borderShadowColor,t.stroke(m),e.path=m,e.ctx=t,drawArrowHeadOnCurve(t,g,{angle:f,adjust:u},d),drawArrowHeadOnCurve(t,b,{angle:x,adjust:h},c)}LineAnnotation.defaults={adjustScaleRange:!0,arrowHeads:{display:!1,end:Object.assign({},arrowHeadsDefaults),fill:!1,length:12,start:Object.assign({},arrowHeadsDefaults),width:6},borderDash:[],borderDashOffset:0,borderShadowColor:"transparent",borderWidth:2,curve:!1,controlPoint:{y:"-50%"},display:!0,endValue:void 0,init:void 0,label:{backgroundColor:"rgba(0,0,0,0.8)",backgroundShadowColor:"transparent",borderCapStyle:"butt",borderColor:"black",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderRadius:6,borderShadowColor:"transparent",borderWidth:0,callout:Object.assign({},LabelAnnotation.defaults.callout),color:"#fff",content:null,display:!1,drawTime:void 0,font:{family:void 0,lineHeight:void 0,size:void 0,style:void 0,weight:"bold"},height:void 0,opacity:void 0,padding:6,position:"center",rotation:0,shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,textAlign:"center",textStrokeColor:void 0,textStrokeWidth:0,width:void 0,xAdjust:0,yAdjust:0,z:void 0},scaleID:void 0,shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,value:void 0,xMax:void 0,xMin:void 0,xScaleID:void 0,yMax:void 0,yMin:void 0,yScaleID:void 0,z:0},LineAnnotation.descriptors={arrowHeads:{start:{_fallback:!0},end:{_fallback:!0},_fallback:!0}},LineAnnotation.defaultRoutes={borderColor:"color"};class EllipseAnnotation extends Element{inRange(t,e,o,n){const i=this.options.rotation,r=this.options.borderWidth;if("x"!==o&&"y"!==o)return pointInEllipse({x:t,y:e},this.getProps(["width","height","centerX","centerY"],n),i,r);const{x:a,y:s,x2:l,y2:d}=this.getProps(["x","y","x2","y2"],n),c=r/2,u="y"===o?{start:s,end:d}:{start:a,end:l},h=rotated({x:t,y:e},this.getCenterPoint(n),toRadians(-i));return h[o]>=u.start-c-EPSILON&&h[o]<=u.end+c+EPSILON}getCenterPoint(t){return getElementCenterPoint(this,t)}draw(t){const{width:e,height:o,centerX:n,centerY:i,options:r}=this;t.save(),translate(t,this.getCenterPoint(),r.rotation),setShadowStyle(t,this.options),t.beginPath(),t.fillStyle=r.backgroundColor;const a=setBorderStyle(t,r);t.ellipse(n,i,o/2,e/2,PI/2,0,2*PI),t.fill(),a&&(t.shadowColor=r.borderShadowColor,t.stroke()),t.restore()}get label(){return this.elements&&this.elements[0]}resolveElementProperties(t,e){return resolveBoxAndLabelProperties(t,e)}}function pointInEllipse(t,e,o,n){const{width:i,height:r,centerX:a,centerY:s}=e,l=i/2,d=r/2;if(l<=0||d<=0)return!1;const c=toRadians(o||0),u=n/2||0,h=Math.cos(c),p=Math.sin(c),y=Math.pow(h*(t.x-a)+p*(t.y-s),2),f=Math.pow(p*(t.x-a)-h*(t.y-s),2);return y/Math.pow(l+u,2)+f/Math.pow(d+u,2)<=1.0001}EllipseAnnotation.id="ellipseAnnotation",EllipseAnnotation.defaults={adjustScaleRange:!0,backgroundShadowColor:"transparent",borderDash:[],borderDashOffset:0,borderShadowColor:"transparent",borderWidth:1,display:!0,init:void 0,label:Object.assign({},BoxAnnotation.defaults.label),rotation:0,shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,xMax:void 0,xMin:void 0,xScaleID:void 0,yMax:void 0,yMin:void 0,yScaleID:void 0,z:0},EllipseAnnotation.defaultRoutes={borderColor:"color",backgroundColor:"color"},EllipseAnnotation.descriptors={label:{_fallback:!0}};class PointAnnotation extends Element{inRange(t,e,o,n){const{x:i,y:r,x2:a,y2:s,width:l}=this.getProps(["x","y","x2","y2","width"],n),d=this.options.borderWidth;if("x"!==o&&"y"!==o)return inPointRange({x:t,y:e},this.getCenterPoint(n),l/2,d);const c=d/2,u="y"===o?{start:r,end:s,value:e}:{start:i,end:a,value:t};return u.value>=u.start-c&&u.value<=u.end+c}getCenterPoint(t){return getElementCenterPoint(this,t)}draw(t){const e=this.options,o=e.borderWidth;if(e.radius<.1)return;t.save(),t.fillStyle=e.backgroundColor,setShadowStyle(t,e);const n=setBorderStyle(t,e);drawPoint(t,this,this.centerX,this.centerY),n&&!isImageOrCanvas(e.pointStyle)&&(t.shadowColor=e.borderShadowColor,t.stroke()),t.restore(),e.borderWidth=o}resolveElementProperties(t,e){const o=resolvePointProperties(t,e);return o.initProperties=initAnimationProperties(t,o,e),o}}PointAnnotation.id="pointAnnotation",PointAnnotation.defaults={adjustScaleRange:!0,backgroundShadowColor:"transparent",borderDash:[],borderDashOffset:0,borderShadowColor:"transparent",borderWidth:1,display:!0,init:void 0,pointStyle:"circle",radius:10,rotation:0,shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,xAdjust:0,xMax:void 0,xMin:void 0,xScaleID:void 0,xValue:void 0,yAdjust:0,yMax:void 0,yMin:void 0,yScaleID:void 0,yValue:void 0,z:0},PointAnnotation.defaultRoutes={borderColor:"color",backgroundColor:"color"};class PolygonAnnotation extends Element{inRange(t,e,o,n){if("x"!==o&&"y"!==o)return this.options.radius>=.1&&this.elements.length>1&&pointIsInPolygon(this.elements,t,e,n);const i=rotated({x:t,y:e},this.getCenterPoint(n),toRadians(-this.options.rotation)),r=this.elements.map((t=>"y"===o?t.bY:t.bX)),a=Math.min(...r),s=Math.max(...r);return i[o]>=a&&i[o]<=s}getCenterPoint(t){return getElementCenterPoint(this,t)}draw(t){const{elements:e,options:o}=this;t.save(),t.beginPath(),t.fillStyle=o.backgroundColor,setShadowStyle(t,o);const n=setBorderStyle(t,o);let i=!0;for(const o of e)i?(t.moveTo(o.x,o.y),i=!1):t.lineTo(o.x,o.y);t.closePath(),t.fill(),n&&(t.shadowColor=o.borderShadowColor,t.stroke()),t.restore()}resolveElementProperties(t,e){const o=resolvePointProperties(t,e),{sides:n,rotation:i}=e,r=[],a=2*PI/n;let s=i*RAD_PER_DEG;for(let i=0;i<n;i++,s+=a){const n=buildPointElement(o,e,s);n.initProperties=initAnimationProperties(t,o,e),r.push(n)}return o.elements=r,o}}function buildPointElement({centerX:t,centerY:e},{radius:o,borderWidth:n},i){const r=n/2,a=Math.sin(i),s=Math.cos(i),l={x:t+a*o,y:e-s*o};return{type:"point",optionScope:"point",properties:{x:l.x,y:l.y,centerX:l.x,centerY:l.y,bX:t+a*(o+r),bY:e-s*(o+r)}}}function pointIsInPolygon(t,e,o,n){let i=!1,r=t[t.length-1].getProps(["bX","bY"],n);for(const a of t){const t=a.getProps(["bX","bY"],n);t.bY>o!=r.bY>o&&e<(r.bX-t.bX)*(o-t.bY)/(r.bY-t.bY)+t.bX&&(i=!i),r=t}return i}PolygonAnnotation.id="polygonAnnotation",PolygonAnnotation.defaults={adjustScaleRange:!0,backgroundShadowColor:"transparent",borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderShadowColor:"transparent",borderWidth:1,display:!0,init:void 0,point:{radius:0},radius:10,rotation:0,shadowBlur:0,shadowOffsetX:0,shadowOffsetY:0,sides:3,xAdjust:0,xMax:void 0,xMin:void 0,xScaleID:void 0,xValue:void 0,yAdjust:0,yMax:void 0,yMin:void 0,yScaleID:void 0,yValue:void 0,z:0},PolygonAnnotation.defaultRoutes={borderColor:"color",backgroundColor:"color"};const annotationTypes={box:BoxAnnotation,ellipse:EllipseAnnotation,label:LabelAnnotation,line:LineAnnotation,point:PointAnnotation,polygon:PolygonAnnotation};Object.keys(annotationTypes).forEach((t=>{defaults.describe(`elements.${annotationTypes[t].id}`,{_fallback:"plugins.annotation.common"})}));const directUpdater={update:Object.assign},hooks$1=eventHooks.concat(elementHooks),resolve=(t,e)=>isObject(e)?resolveObj(t,e):t,isIndexable=t=>"color"===t||"font"===t;function resolveType(t="line"){return annotationTypes[t]?t:(console.warn(`Unknown annotation type: '${t}', defaulting to 'line'`),"line")}function updateElements(t,e,o,n){const i=resolveAnimations(t,o.animations,n),r=e.annotations,a=resyncElements(e.elements,r);for(let e=0;e<r.length;e++){const o=r[e],n=getOrCreateElement(a,e,o.type),s=o.setContext(getContext(t,n,o)),l=n.resolveElementProperties(t,s);l.skip=toSkip(l),"elements"in l&&(updateSubElements(n,l.elements,s,i),delete l.elements),defined(n.x)||Object.assign(n,l),Object.assign(n,l.initProperties),l.options=resolveAnnotationOptions(s),i.update(n,l)}}function toSkip(t){return isNaN(t.x)||isNaN(t.y)}function resolveAnimations(t,e,o){return"reset"===o||"none"===o||"resize"===o?directUpdater:new Animations(t,e)}function updateSubElements(t,e,o,n){const i=t.elements||(t.elements=[]);i.length=e.length;for(let t=0;t<e.length;t++){const r=e[t],a=r.properties,s=getOrCreateElement(i,t,r.type,r.initProperties),l=o[r.optionScope].override(r);a.options=resolveAnnotationOptions(l),n.update(s,a)}}function getOrCreateElement(t,e,o,n){const i=annotationTypes[resolveType(o)];let r=t[e];return r&&r instanceof i||(r=t[e]=new i,Object.assign(r,n)),r}function resolveAnnotationOptions(t){const e=annotationTypes[resolveType(t.type)],o={};o.id=t.id,o.type=t.type,o.drawTime=t.drawTime,Object.assign(o,resolveObj(t,e.defaults),resolveObj(t,e.defaultRoutes));for(const e of hooks$1)o[e]=t[e];return o}function resolveObj(t,e){const o={};for(const n of Object.keys(e)){const i=e[n],r=t[n];isIndexable(n)&&isArray(r)?o[n]=r.map((t=>resolve(t,i))):o[n]=resolve(r,i)}return o}function getContext(t,e,o){return e.$context||(e.$context=Object.assign(Object.create(t.getContext()),{element:e,id:o.id,type:"annotation"}))}function resyncElements(t,e){const o=e.length,n=t.length;if(n<o){const e=o-n;t.splice(n,0,...new Array(e))}else n>o&&t.splice(o,n-o);return t}var version="3.0.1";const chartStates=new Map,hooks=eventHooks.concat(elementHooks);var annotation={id:"annotation",version:version,beforeRegister(){requireVersion("chart.js","4.0",Chart.version)},afterRegister(){Chart.register(annotationTypes)},afterUnregister(){Chart.unregister(annotationTypes)},beforeInit(t){chartStates.set(t,{annotations:[],elements:[],visibleElements:[],listeners:{},listened:!1,moveListened:!1,hooks:{},hooked:!1,hovered:[]})},beforeUpdate(t,e,o){const n=chartStates.get(t).annotations=[];let i=o.annotations;isObject(i)?Object.keys(i).forEach((t=>{const e=i[t];isObject(e)&&(e.id=t,n.push(e))})):isArray(i)&&n.push(...i),verifyScaleOptions(n,t.scales)},afterDataLimits(t,e){const o=chartStates.get(t);adjustScaleRange(t,e.scale,o.annotations.filter((t=>t.display&&t.adjustScaleRange)))},afterUpdate(t,e,o){const n=chartStates.get(t);updateListeners(t,n,o),updateElements(t,n,o,e.mode),n.visibleElements=n.elements.filter((t=>!t.skip&&t.options.display)),updateHooks(t,n,o)},beforeDatasetsDraw(t,e,o){draw(t,"beforeDatasetsDraw",o.clip)},afterDatasetsDraw(t,e,o){draw(t,"afterDatasetsDraw",o.clip)},beforeDraw(t,e,o){draw(t,"beforeDraw",o.clip)},afterDraw(t,e,o){draw(t,"afterDraw",o.clip)},beforeEvent(t,e,o){handleEvent(chartStates.get(t),e.event,o)&&(e.changed=!0)},afterDestroy(t){chartStates.delete(t)},_getState:t=>chartStates.get(t),defaults:{animations:{numbers:{properties:["x","y","x2","y2","width","height","centerX","centerY","pointX","pointY","radius"],type:"number"}},clip:!0,interaction:{mode:void 0,axis:void 0,intersect:void 0},common:{drawTime:"afterDatasetsDraw",init:!1,label:{}}},descriptors:{_indexable:!1,_scriptable:t=>!hooks.includes(t)&&"init"!==t,annotations:{_allKeys:!1,_fallback:(t,e)=>`elements.${annotationTypes[resolveType(e.type)].id}`},interaction:{_fallback:!0},common:{label:{_indexable:isIndexable,_fallback:!0},_indexable:isIndexable}},additionalOptionScopes:[""]};function draw(t,e,o){const{ctx:n,chartArea:i}=t,r=chartStates.get(t);o&&clipArea(n,i);const a=getDrawableElements(r.visibleElements,e).sort(((t,e)=>t.element.options.z-e.element.options.z));for(const t of a)drawElement(n,i,r,t);o&&unclipArea(n)}function getDrawableElements(t,e){const o=[];for(const n of t)if(n.options.drawTime===e&&o.push({element:n,main:!0}),n.elements&&n.elements.length)for(const t of n.elements)t.options.display&&t.options.drawTime===e&&o.push({element:t});return o}function drawElement(t,e,o,n){const i=n.element;n.main?(invokeHook(o,i,"beforeDraw"),i.draw(t,e),invokeHook(o,i,"afterDraw")):i.draw(t,e)}export{annotation as default};
//# sourceMappingURL=/sm/23e4c89249c37ea1962b5f5ab622c1239b6c3253ee1c7982645835fa0781d037.map